\chapter{面向矩阵乘法的代码自动生成工具}\label{chap:codegen}

本章节详细介绍了面向矩阵乘法的代码自动生成工具框架，主要包含以下几个部分：

\begin{itemize}
    \item 领域特定语言(Domain Specific Language)及其语法分析器(Parser)
    \item 调度树(Schedule Tree)对矩阵计算任务的建模
    \item 以及中间表示(Intermediate Representation)
    \item 基于 AST 变换的编译优化算法
    \item 代码生成工具(Code Generator)
\end{itemize}

\section{针对矩阵计算问题的建模}

芯片的理论峰值计算性能往往由计算核心的数量、峰值频率、指令发射宽度、每条指令完成多少浮点计算，这几个参数相乘来得到。

矩阵乘法算法作为一个计算密集型的算法，往往期望跑到 90\%以上的峰值性能即充分利用芯片的计算能力。但是，较高的目标峰值性能，对访存系统的延迟和带宽，软件算法的设计也提出了较高的要求。

近年来 CPU 还是 GPU 都在不断优化主存带宽，例如使用 DDR5、 HBM 等更先进的存储硬件。同时也都使用了芯片内高速缓存 Cache，来降低数据的延迟。高速缓存 Cache 离计算单元物理距离更近，并且 SRAM 的硬件特性，能够有效降低数据延迟。同时配合配合矩阵乘法算法中的分块优化思路，将一部分会重复读取的数据放在高速缓存中，能够减少对主存的访问。

全局的高速缓存，还需要解决缓存一致性的问题，这在某种程度上，限制和核心数量的扩张，同时过多的缓存一致性冲突也会导致算法运行效率的降低。分布式可编程高速缓存则是很好得解决了这一问题，该技术得到了广泛的应用，例如 SW26010P 上的LDM和NVIDIA GPU 中的共享内存(Shared Memory)

在矩阵乘法中，不论是在 GPU 还是 CPU 的平台，优先在M N 这两个维度上进行任务划分。（TODO 这里插入 thread block swizzle 的图片，下图中的 Block(0,0) 和 Block(1,0) 都需要读取 A 矩阵的第一个行块。也就是说在相同行的 Block 都需要同一行 A 的数据，相同列的Block 都需要同一列 B 矩阵的数据。这里也存在着重复数据读取的问题，在 GPU 和 SW26010P 处理器中，这部分数据可以被 L2 Cache 缓存，例如 GPU 中的矩阵乘法算法往往会用 ThreadBlock Swizzle 这一优化策略来提高 L2 Cache 的命中率。另外片上网络设计的引入，也可以更优雅的解决这一问题。

片上网络的引入和优势。正如前文TODO所提到的，SW26010P 处理器，在一个核组，即 64 个从核之间共享一个片上交换网络，并且该网络构成二维网格的组成形式。同样 NVIDIA GPU 在 hopper 架构中也引入了 Shared Memory 之间的通信机制 (TODO 插入片上网络通信的图片)。在 Groq AI 推理芯片中，在矩阵乘法的计算中也是用片上网络的通信机制。

随着体系结构的发展，市面上出现了一些具备片上网络和核内分布式高速缓存的处理器，例如特斯拉的 DOJO，NVIDIA 的 HOPPER还有 SW26010P 处理器等。片上网络的特点和使用基于消息通信机制

本研究针对分布式可编程高速缓存和核间片上网络的特点，结合矩阵乘法的特点，设计了一套用于矩阵乘法的代码自动生成框架。




\section{领域特定语言(Domain Specific Language)}


\section{面向矩阵乘法IR设计}

\subsection{DMA}


\subsection{RMA}


\subsection{MMA}

\subsection{其他IR}




\section{用于优化的各种AST变换}

\subsection{循环展开变换}

\subsection{循环消除变换}

在实际的应用当中，用户可能会需要一个特定规模的矩阵乘法，利用这个矩阵的规模信息我们能对矩阵乘法进行进一步的性能提升。结合后续章节提到的动态调优技术，我们能生成一套覆盖所有范围，并且针对某个区间调优的矩阵乘法库。

例如，在上面的例子中，我们可以看到，矩阵乘法的规模是 $M \times N \times K$，针对特定的规模信息，我们可以对前面生成的 AST 进行优化。

\subsection{循环不变式外提变换}

本研究使用了编译器技术中，循环不变式外提的中端优化技术，

循环不变式外提技术的定义。循环不变式外提（Loop Invariant Code Motion，简称LICM）是一种编译器优化技术，旨在提高程序运行效率。它识别循环中的那些计算，这些计算在每次迭代中都产生相同的结果，也就是说，这些计算与循环变量的值无关，因而被称为“循环不变式”。一旦识别出循环不变式，编译器就会将这些计算从循环体中移动到循环之前，从而减少每次循环迭代时的计算量。


TODO 循环不变式外提的实现算法


TODO 循环不变式起作用的例子，以及对访存量的影响





\subsection{软件流水线变换}

软件流水线的定义。软件流水线（Software Pipelining）是一种高级循环优化技术，用于提高处理器执行并行性的一种编译时技术。它通过重新组织循环体内指令的执行顺序，使得在每个循环迭代中，可以同时对多个迭代的不同部分执行操作，类似于硬件流水线中不同阶段同时处理多个指令的方式。这样做的目的是在保持循环逻辑不变的前提下，最大化指令级并行（ILP），减少循环迭代之间的依赖性，提高CPU利用率和程序执行效率。

在 SW26010P 处理器中，我们主要使用两层软件流水线设计。
第一层是在分块矩阵乘法，也就是 MMA 中。正如上文所提到的，这部分主要通过手写的汇编指令，实现LDM 到寄存器的读写指令，和SIMD 计算指令之间的异步并行。
第二层则是在中间表示 IR 的粒度上，来构建流水线。SW26010P 支持异步 DMA读写，以及异步 RMA 数据通信，计算则是需要同步完成。因此软件流水线主要发生于DMA、 RMA 、 MMA个阶段。




